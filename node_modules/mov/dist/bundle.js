(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
const Class = require('cify');
const Template = require('./template');

const Component = function (classOpts) {

  return new Class({
    _extends: classOpts,
    constructor: function (instanceOpts) {

    }
  });

};

module.exports = Component;
},{"./template":11,"cify":14}],2:[function(require,module,exports){
const Template = require('./template');
const Component = require('./component');
const pkg = require('../package.json');
const utils = require('ntils');

Component.version = pkg.version;
utils.copy(Template, Component);
Component.Component = Component;

//普通脚本引入
if (window) window[pkg.name] = Component;
//amd 模块
if (typeof define !== 'undefined' && define.amd) {
  define(pkg.name, [], function () {
    return Component;
  });
}
//commonjs 模块
module.exports = Component;
},{"../package.json":16,"./component":1,"./template":11,"ntils":15}],3:[function(require,module,exports){
const Class = require('cify');
const Directive = require('./directive');
const utils = require('./utils');
const Expression = require('./expression');

const Compiler = new Class({

  constructor: function (options) {
    options = options || {};
    this.directives = options.directives || [];
  },

  findDirectives: function (type, name) {
    return this.directives.filter(function (Directive) {
      return Directive.type == type && Directive.regexp.test(name);
    }, this);
  },

  _initDirectives: function (handler) {
    //排序 directives
    handler.directives = handler.directives.sort(function (a, b) {
      return b.level - a.level;
    });
    //初始化 directives
    var initedDirectives = [];
    utils.each(handler.directives, function (index, directive) {
      directive.index = index;
      directive.init();
      initedDirectives.push(directive);
      if (directive.final) return handler.final = true;
    }, this);
    handler.directives = initedDirectives;
  },

  _compileElement: function (handler, node) {
    var elementDirectives = this.findDirectives(Directive.TYPE_ELEMENT, node.nodeName);
    elementDirectives.forEach(function (Directive) {
      handler.directives.push(new Directive({
        compiler: this,
        handler: handler,
        node: node
      }));
    }, this);
  },

  _compileAttributes: function (handler, node) {
    utils.toArray(node.attributes).forEach(function (attribute) {
      var attributeDirectives = this.findDirectives(Directive.TYPE_ATTRIBUTE, attribute.name);
      attributeDirectives.forEach(function (Directive) {
        handler.directives.push(new Directive({
          compiler: this,
          handler: handler,
          node: node,
          attribute: attribute,
          expression: Directive.expression ? new Expression(attribute.value) : null
        }));
      }, this);
    }, this);
  },

  _compileChildren: function (handler, node) {
    if (handler.final) return;
    utils.toArray(node.childNodes).forEach(function (childNode) {
      var childhandler = this.compile(childNode);
      childhandler.parent = this;
      handler.children.push(childhandler);
    }, this);
  },

  compile: function (node) {
    node._parentNode = node._parentNode || node.parentNode;
    //定义编译结果函数
    var handler = function (scope) {
      //执行指令
      handler.directives.forEach(function (directive) {
        directive.execute(scope);
      }, this);
      //执行子元素编译函数
      handler.children.forEach(function (childhandler) {
        childhandler(scope);
      }, this);
    };
    //定义 children & directives 
    handler.directives = [];
    handler.children = [];
    //编辑相关指令
    this._compileElement(handler, node);
    this._compileAttributes(handler, node);
    this._initDirectives(handler);
    this._compileChildren(handler, node);
    //返回编译后函数
    return handler;
  }

});

module.exports = Compiler;
},{"./directive":4,"./expression":10,"./utils":13,"cify":14}],4:[function(require,module,exports){
const Class = require('cify');
const utils = require('./utils');
const Expression = require('./expression');

const Directive = function (classOpts) {
  classOpts = classOpts || {};
  if (!utils.isString(classOpts.name) || classOpts.name.length < 1) {
    throw new Error('Invalid directive name "' + classOpts.name + '"');
  }
  if (Directive.NS) {
    classOpts.fullName = Directive.NS + ':' + classOpts.name;
  } else {
    classOpts.fullName = classOpts.name;
  }
  classOpts.Expression = Expression;
  classOpts.utils = utils;
  const DirectiveClass = new Class({
    _extends: classOpts,
    constructor: function (instanceOpts) {
      //实例本身属性或方法
      utils.copy(instanceOpts, this);
    }
  });
  utils.copy(classOpts, DirectiveClass);
  utils.defineProperty(DirectiveClass, 'name', {
    get: function () { return classOpts.name; }
  });
  DirectiveClass.type = classOpts.type || Directive.TYPE_ATTRIBUTE;
  DirectiveClass.level = classOpts.level || Directive.LEVEL_GENERAL;
  DirectiveClass.regexp = classOpts.regexp || classOpts.fullName;
  if (!(DirectiveClass.regexp instanceof RegExp)) {
    DirectiveClass.regexp = new RegExp('^' + DirectiveClass.regexp + '$', 'i');
  }
  return DirectiveClass;
};

//指令类型
Directive.TYPE_ATTRIBUTE = 'attribute';
Directive.TYPE_ELEMENT = 'element';

//指令级别
Directive.LEVEL_ATTRIBUTE = -1000;
Directive.LEVEL_GENERAL = 0;
Directive.LEVEL_STATEMENT = 1000;

module.exports = Directive;
},{"./expression":10,"./utils":13,"cify":14}],5:[function(require,module,exports){
const Directive = require('../directive');

module.exports = new Directive({
  name: 'attr',
  type: Directive.TYPE_ATTRIBUTE,
  level: Directive.LEVEL_ATTRIBUTE,
  regexp: /[\s\S]/i,

  init: function () {
    this.computedName = this.attribute.name;
    this.computedValue = this.attribute.value;
    this.nameExpr = new this.Expression(this.attribute.name, true);
    this.valueExpr = new this.Expression(this.attribute.value, true);
  },

  execute: function (scope) {
    var newComputedName = this.nameExpr.execute(scope);
    if (this.computedName !== newComputedName) {
      this.node.removeAttribute(this.computedName);
      this.computedName = newComputedName;
      if (!this.utils.isNull(this.computedName) && this.computedName.length > 0) {
        this.node.setAttribute(this.computedName, '');
      }
    }
    var newComputeValue = this.valueExpr.execute(scope);
    newComputeValue = this.utils.isNull(newComputeValue) ? '' : newComputeValue;
    if (this.computedValue !== newComputeValue) {
      this.computedValue = newComputeValue;
      this.node.setAttribute(
        this.computedName,
        this.computedValue
      );
    }
  }

});
},{"../directive":4}],6:[function(require,module,exports){
const Directive = require('../directive');

module.exports = new Directive({
  name: 'each',
  type: Directive.TYPE_ATTRIBUTE,
  level: Directive.LEVEL_STATEMENT,
  final: true,

  init: function () {
    this.mountNode = document.createTextNode('');
    this.node.parentNode.insertBefore(this.mountNode, this.node);
    this.node.removeAttribute(this.fullName);
    this.node.parentNode.removeChild(this.node);
    this._parseExpr();
    this._items = [];
  },

  _parseExpr: function () {
    this._type = this.attribute.value.indexOf(' in ') > -1 ? 'in' : 'of';
    var tokens = this.attribute.value.split(' ' + this._type + ' ');
    var fnText = 'utils.each(utils.getByPath(scope,"' + tokens[1] + '"),fn,this)';
    this._each = new Function('utils', 'scope', 'fn', fnText);
    var names = tokens[0].split(',').map(function (name) {
      return name.trim();
    });
    if (this._type == 'in') {
      this._index = names[0];
      this._item = names[1];
    } else {
      this._index = names[1];
      this._item = names[0];
    }
  },

  execute: function (scope) {
    var lastIndex = -1;
    var docfrag = document.createDocumentFragment();
    this._each(this.utils, scope, function (index, item) {
      //创建新 scope
      var newScope = this.utils.copy(scope);
      if (this._index) newScope[this._index] = index;
      if (this._item) newScope[this._item] = item;
      var oldItem = this._items[index];
      if (oldItem) {
        oldItem.handler(newScope);
      } else {
        var newItem = {};
        //创建新元素
        newItem.node = this.node.cloneNode(true);
        docfrag.appendChild(newItem.node);
        newItem.node._parentNode = this.node._parentNode;
        newItem.handler = this.compiler.compile(newItem.node);
        newItem.handler(newScope);
        this._items[index] = newItem;
      }
      lastIndex = index;
    }, this);
    this._items.splice(lastIndex + 1).forEach(function (item) {
      item.node.parentNode.removeChild(item.node);
    });
    if (docfrag.childNodes.length > 0) {
      this.mountNode.parentNode.insertBefore(docfrag, this.mountNode);
    }
  }

});
},{"../directive":4}],7:[function(require,module,exports){
const Directive = require('../directive');

module.exports = new Directive({
  name: 'if',
  type: Directive.TYPE_ATTRIBUTE,
  level: Directive.LEVEL_STATEMENT,
  final: true,
  expression: true,

  init: function () {
    this.mountNode = document.createTextNode('');
    this.node.parentNode.insertBefore(this.mountNode, this.node);
    this.node.removeAttribute(this.fullName);
    this.node.parentNode.removeChild(this.node);
    this.state = false;
    this.handler = this.compiler.compile(this.node);
  },

  execute: function (scope) {
    var newState = this.expression.execute(scope);
    if (newState) {
      this.handler(scope);
      if (!this.state) {
        this.mountNode.parentNode.insertBefore(this.node, this.mountNode);
      }
    } else if (this.state) {
      this.node.parentNode.removeChild(this.node);
    }
    this.state = newState;
  }

});
},{"../directive":4}],8:[function(require,module,exports){
module.exports = [
  require('./text'),
  require('./attr'),
  require('./each'),
  require('./if')
];
},{"./attr":5,"./each":6,"./if":7,"./text":9}],9:[function(require,module,exports){
const Directive = require('../directive');
const Expression = require('../expression');

module.exports = new Directive({
  name: '#text',
  type: Directive.TYPE_ELEMENT,

  init: function () {
    this.nodeValue = this.node.nodeValue;
    this.expr = new Expression(this.node.nodeValue, true);
  },

  execute: function (scope) {
    var newNodeValue = this.expr.execute(scope);
    if (this.nodeValue !== newNodeValue) {
      this.nodeValue = newNodeValue;
      this.node.nodeValue = this.nodeValue;
    };
  }

});
},{"../directive":4,"../expression":10}],10:[function(require,module,exports){
const Class = require('cify');
const utils = require('./utils');

const Expression = new Class({

  constructor: function (code, mix) {
    this.func = mix ? this._compileMixedCode(code) : this._compileCode(code);
  },

  _compileCode: function (code) {
    code = this._escapeEOL(this._wrapCode(code));
    return new Function('scope', 'with(scope){return ' + code + '}');
  },

  _compileMixedCode: function (code) {
    var statements = this._parseMixedCode(code);
    code = this._escapeEOL(statements.join('+'));
    return new Function('scope', 'with(scope){return ' + code + '}');
  },

  _parseMixedCode: function (code) {
    var index = 0, length = code.length;
    var token = '', isExpr = false, tokens = [];
    while (index <= length) {
      var char = code[index++];
      var nextChar = code[index];
      if (utils.isNull(char)) {
        if (token.length > 0) {
          tokens.push('"' + this._escapeCode(token) + '"');
        }
        token = '';
        isExpr = false;
      } else if (!isExpr && char + nextChar == '{{') {
        if (token.length > 0) {
          tokens.push('"' + this._escapeCode(token) + '"');
        }
        token = '';
        isExpr = true;
        index++;
      } else if (isExpr && char + nextChar == '}}') {
        if (token.length > 0) {
          tokens.push(this._wrapCode(token));
        }
        token = '';
        isExpr = false;
        index++;
      } else {
        token += char;
      }
    }
    return tokens;
  },

  _escapeCode: function (str) {
    return str.replace(/"/, '\\"').replace('\r\n', '\\r\\n').replace('\n', '\\n');
  },

  _wrapCode: function (code) {
    return '((function(){try{return (' + code + ')}catch(err){return ""}})())';
  },

  _escapeEOL: function (code) {
    return code.replace(/\n/gm, '\\\n');
  },

  execute: function (scope) {
    scope = scope || {};
    return this.func.call(scope, scope);
  }

});

module.exports = Expression;
},{"./utils":13,"cify":14}],11:[function(require,module,exports){
const Compiler = require('./compiler');
const Directive = require('./directive');
const Expression = require('./expression');
const Template = require('./template');
const directives = require('./directives/');
const utils = require('./utils');

const compiler = new Compiler({
  directives: directives
});

Template.Template = Template;
Template.Compiler = Compiler;
Template.compiler = compiler;
Template.Directive = Directive;
Template.Expression = Expression;
Template.utils = utils;

module.exports = Template;
},{"./compiler":3,"./directive":4,"./directives/":8,"./expression":10,"./template":12,"./utils":13}],12:[function(require,module,exports){
const Class = require('cify');
const utils = require('./utils');

const Template = new Class({

  constructor: function (element, compiler) {
    this.element = element;
    this.compiler = compiler || Template.compiler;
    this.render = this.compiler.compile(this.element);
  }

});

module.exports = Template;
},{"./utils":13,"cify":14}],13:[function(require,module,exports){
const utils = require('ntils');
module.exports = utils;

utils.toArray = function (list) {
  if (!list) return [];
  return [].slice.call(list);
};

utils.NOOP = function () { };

utils.includeExpr = function (str) {
  if (!str) return false;
  return str.indexOf('{{') > -1 && str.indexOf('}}') > -1;
};

utils.wrapScope = function (scope) {
  scope = scope || {};
  utils.each(window, function (name) {
    scope[name] = scope[name] || null;
  }, this);
  return scope;
};
},{"ntils":15}],14:[function(require,module,exports){
; (function () {
  var createInstance = (function () {
    var fnBody = ['switch(args.length){']
    for (var i = 20; i > 0; i--) {
      var fnArgs = []
      for (var j = 0; j < i; j++) fnArgs.push('args[' + j + ']')
      fnBody.push('case ' + i + ':return new Fn(' + fnArgs.join(',') + ');')
    }
    fnBody.push('case 0:default:return new Fn();}')
    return new Function('Fn', 'args', fnBody.join(''))
  })()

  function getPropertyNames(obj) {
    var nameList = Object.getOwnPropertyNames(obj)
    if (obj.__proto__) {
      nameList.push.apply(nameList, getPropertyNames(obj.__proto__))
    }
    return nameList
  }

  function isChildClass(_child, _super) {
    if (_child.__proto__ == _super.prototype) {
      return true
    } else if (_child.prototype) {
      return isChildClass(_child.prototype, _super)
    } else {
      return false
    }
  }

  function createSuper(_self, proto) {
    var _super = function () {
      if (proto.constructor) {
        proto.constructor.apply(_self, arguments)
      }
    }
    delete _super.name
    var nameList = getPropertyNames(proto)
    nameList.forEach(function (name) {
      if (name == '_super' ||
        name == '_extends' ||
        name == '_static' ||
        name == 'constructor') {
        return
      }
      if (typeof proto[name] === 'function') {
        _super[name] = _super[name] || proto[name].bind(_self)
      } else {
        _super[name] = _super[name] || proto[name]
      }
    })
    _super.__proto__ = {}
    return _super
  }

  function defineClass(def) {
    var classProto = ((typeof def === 'function') ? def() : def) || {}
    var classExtends = classProto._extends
    var clsssStatic = classProto._static || {}
    if (typeof classExtends === 'function') {
      classProto.__proto__ = classExtends.prototype
      clsssStatic.__proto__ = classExtends
    } else if (classExtends) {
      classProto.__proto__ = classExtends
    } else {
      classProto.__proto__ = {}
    }
    classProto.__defineGetter__('_super', function () {
      this.__super__ = this.__super__ || createSuper(this, classProto.__proto__)
      return this.__super__
    })
    Class.prototype = classProto
    Class.__proto__ = clsssStatic
    function Class() {
      var instance = this
      if (typeof classExtends === 'function') {
        instance = createInstance(classExtends, arguments)
      }
      instance.constructor = Class
      instance._static = instance.Class = Class
      instance.__proto__ = Class.prototype
      var constructor = instance.__proto__.constructor
      if (constructor != null &&
        constructor != Object) {
        var rs = constructor.apply(instance, arguments)
        instance = rs && classProto.hasOwnProperty('constructor') ? rs : instance
      }
      instance.__proto__ = Class.prototype
      delete instance._extends
      return instance
    }
    Class.extendsOf = function (_super) {
      return isChildClass(this, _super)
    };
    Class.superOf = function (_child) {
      return isChildClass(_child, this)
    };
    return Class
  }

  defineClass.prototype.__proto__ = Function.prototype
  defineClass.Class = defineClass

  if (typeof module != 'undefined') {
    module.exports = defineClass
  }

  if (typeof define == 'function' && define.amd) {
    define('cify', [], function () {
      return defineClass
    })
  }

  if (typeof window != 'undefined') {
    window.cify = window.Class = defineClass
  }
})()

},{}],15:[function(require,module,exports){
(function (owner) {
  "use strict";

  /**
   * 验证一个对象是否为NULL
   * @method isNull
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isNull = function (obj) {
    return obj === null || typeof obj === "undefined";
  };

  /**
   * 除去字符串两端的空格
   * @method trim
   * @param  {String} str 源字符串
   * @return {String}     结果字符串
   * @static
   */
  owner.trim = function (str) {
    if (this.isNull(str)) return str;
    if (str.trim) {
      return str.trim();
    } else {
      return str.replace(/(^[\\s]*)|([\\s]*$)/g, "");
    }
  };

  /**
   * 替换所有
   * @method replace
   * @param {String} str 源字符串
   * @param {String} str1 要替换的字符串
   * @param {String} str2 替换为的字符串
   * @static
   */
  owner.replace = function (str, str1, str2) {
    if (this.isNull(str)) return str;
    return str.replace(new RegExp(str1, 'g'), str2);
  };

  /**
   * 从字符串开头匹配
   * @method startWith
   * @param {String} str1 源字符串
   * @param {String} str2 要匹配的字符串
   * @return {Boolean} 匹配结果
   * @static
   */
  owner.startWith = function (str1, str2) {
    if (this.isNull(str1) || this.isNull(str2)) return false;
    return str1.indexOf(str2) === 0;
  };

  /**
   * 是否包含
   * @method contains
   * @param {String} str1 源字符串
   * @param {String} str2 检查包括字符串
   * @return {Boolean} 结果
   * @static
   */
  owner.contains = function (str1, str2) {
    var self = this;
    if (this.isNull(str1) || this.isNull(str2)) return false;
    if (self.isArray(str1)) {
      return self.each(str1, function (i, str) {
        if (str == str2) return true;
      });
    } else {
      return str1 && str2 && str1.indexOf(str2) > -1;
    }
  };

  /**
   * 从字符串结束匹配
   * @method endWidth
   * @param {String} str1 源字符串
   * @param {String} str2 匹配字符串
   * @return {Boolean} 匹配结果
   * @static
   */
  owner.endWith = function (str1, str2) {
    if (this.isNull(str1) || this.isNull(str2)) return false;
    return str1.indexOf(str2) === (str1.length - str2.length);
  };

  /**
   * 是否包含属性
   * @method hasProperty
   * @param  {Object}  obj  对象
   * @param  {String}  name 属性名
   * @return {Boolean}      结果
   * @static
   */
  owner.has = owner.hasProperty = function (obj, name) {
    if (this.isNull(obj) || this.isNull(name)) return false;
    return (name in obj) || (obj.hasOwnProperty(name));
  };

  /**
   * 验证一个对象是否为Function
   * @method isFunction
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isFunction = function (obj) {
    if (this.isNull(obj)) return false;
    return typeof obj === "function";
  };

  /**
   * 验证一个对象是否为String
   * @method isString
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isString = function (obj) {
    if (this.isNull(obj)) return false;
    return typeof obj === 'string' || obj instanceof String;
  };

  /**
   * 验证一个对象是否为Number
   * @method isNumber
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isNumber = function (obj) {
    if (this.isNull(obj)) return false;
    return typeof obj === 'number' || obj instanceof Number;
  };

  /**
   * 验证一个对象是否为Boolean
   * @method isBoolean
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isBoolean = function (obj) {
    if (this.isNull(obj)) return false;
    return typeof obj === 'boolean' || obj instanceof Boolean;
  };

  /**
   * 验证一个对象是否为HTML Element
   * @method isElement
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isElement = function (obj) {
    if (this.isNull(obj)) return false;
    if (window.Element) return obj instanceof Element;
    else return (obj.tagName && obj.nodeType && obj.nodeName && obj.attributes && obj.ownerDocument);
  };

  /**
   * 验证一个对象是否为HTML Text Element
   * @method isText
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isText = function (obj) {
    if (this.isNull(obj)) return false;
    return obj instanceof Text;
  };

  /**
   * 验证一个对象是否为Object
   * @method isObject
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isObject = function (obj) {
    if (this.isNull(obj)) return false;
    return typeof obj === "object";
  };

  /**
   * 验证一个对象是否为Array或伪Array
   * @method isArray
   * @param  {Object}  obj 要验证的对象
   * @return {Boolean}     结果
   * @static
   */
  owner.isArray = function (obj) {
    if (this.isNull(obj)) return false;
    var v1 = Object.prototype.toString.call(obj) === '[object Array]';
    var v2 = obj instanceof Array;
    var v3 = !this.isString(obj) && this.isNumber(obj.length) && this.isFunction(obj.splice);
    var v4 = !this.isString(obj) && this.isNumber(obj.length) && obj[0];
    return v1 || v2 || v3 || v4;
  };

  /**
   * 验证是不是一个日期对象
   * @method isDate
   * @param {Object} val   要检查的对象
   * @return {Boolean}           结果
   * @static
   */
  owner.isDate = function (val) {
    if (this.isNull(val)) return false;
    return val instanceof Date;
  };

  /**
   * 转换为数组
   * @method toArray
   * @param {Array|Object} _aar 伪数组
   * @return {Array} 转换结果数组
   * @static
   */
  owner.toArray = function (_aar) {
    if (this.isNull(_aar)) return [];
    try {
      return Array.prototype.slice.call(_aar);
    } catch (e) {
      var arr = [];
      var lan = _aar.length;
      for (var i = 0; i < len; i++) {
        arr[i] = s[i];
      }
      return arr;
    }
  };

  /**
   * 转为日期格式
   * @method toDate
   * @param {Number|String} val 日期字符串或整型数值
   * @return {Date} 日期对象
   * @static
   */
  owner.toDate = function (val) {
    var self = this;
    if (self.isNumber(val))
      return new Date(val);
    else if (self.isString(val))
      return new Date(self.replace(self.replace(val, '-', '/'), 'T', ' '));
    else if (self.isDate(val))
      return val;
    else
      return null;
  };

  /**
   * 遍历一个对像或数组
   * @method each
   * @param  {Object or Array}   obj  要遍历的数组或对象
   * @param  {Function} fn            处理函数
   * @return {void}                   无返回值
   * @static
   */
  owner.each = function (list, handler, scope) {
    if (this.isNull(list) || this.isNull(handler)) return;
    if (this.isArray(list)) {
      var listLength = list.length;
      for (var i = 0; i < listLength; i++) {
        var rs = handler.call(scope || list[i], i, list[i]);
        if (!this.isNull(rs)) return rs;
      }
    } else {
      for (var key in list) {
        var rs = handler.call(scope || list[key], key, list[key]);
        if (!this.isNull(rs)) return rs;
      }
    }
  };

  /**
   * 格式化日期
   * @method formatDate
   * @param {Date|String|Number} date 日期
   * @param {String} format 格式化字符串
   * @return {String} 格式化结果
   * @static
   */
  owner.formatDate = function (date, format) {
    if (this.isNull(format) || this.isNull(date)) return date;
    date = this.toDate(date);
    var placeholder = {
      "M+": date.getMonth() + 1, //month
      "d+": date.getDate(), //day
      "h+": date.getHours(), //hour
      "m+": date.getMinutes(), //minute
      "s+": date.getSeconds(), //second
      "q+": Math.floor((date.getMonth() + 3) / 3), //quarter
      "S": date.getMilliseconds() //millisecond
    }
    if (/(y+)/.test(format)) {
      format = format.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
    }
    for (var key in placeholder) {
      if (new RegExp("(" + key + ")").test(format)) {
        format = format.replace(RegExp.$1,
          RegExp.$1.length == 1 ? placeholder[key] :
            ("00" + placeholder[key]).substr(("" + placeholder[key]).length));
      }
    }
    return format;
  };

  /**
   * 深度克隆对象
   * @method clone
   * @param {Object} obj 源对象
   * @return {Object} 新对象
   * @static
   */
  owner.clone = function (obj, igonreArray) {
    if (this.isNull(obj) || this.isString(obj) || this.isNumber(obj) || this.isBoolean(obj) || this.isDate(obj)) {
      return obj;
    }
    var objClone = obj;
    try {
      objClone = new obj.constructor();
    } catch (ex) { }
    for (var key in obj) {
      if (objClone[key] != obj[key] && !this.contains(igonreArray, key)) {
        if (typeof (obj[key]) === 'object') {
          objClone[key] = this.clone(obj[key], igonreArray);
        } else {
          objClone[key] = obj[key];
        }
      }
    }
    this.each(['toString', 'valueOf'], function (i, name) {
      if (this.contains(igonreArray, key)) return;
      objClone[name] = obj[name];
    }, this);
    return objClone;
  };

  /**
   * 拷贝对象
   * @method copy
   * @param {Object} obj1 源对象
   * @param {Object} obj2 目标对象
   * @static
   */
  owner.copy = function (obj1, obj2) {
    obj2 = obj2 || {};
    this.each(obj1, function (name) {
      try {
        obj2[name] = obj1[name];
      } catch (ex) { }
    })
    return obj2;
  };

  /**
   * 从一个数值循环到别一个数
   * @param {number} fromNum 开始数值
   * @param {Number} toNum 结束数值
   * @param {Number} step 步长值
   * @param {function} handler 执行函数
   * @returns {void} 无返回
   */
  owner.fromTo = function (fromNum, toNum, step, handler) {
    if (!handler) handler = [step, step = handler][0];
    step = Math.abs(step || 1);
    if (fromNum < toNum) {
      for (var i = fromNum; i <= toNum; i += step) handler(i);
    } else {
      for (var i = fromNum; i >= toNum; i -= step) handler(i);
    }
  };

  /**
   * 生成一个Guid
   * @method newGuid
   * @return {String} GUID字符串
   * @static
   */
  owner.newGuid = function () {
    var S4 = function () {
      return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    };
    return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
  };

  /**
   * 定义属性
   * @method defineProperty
   * @param {Object} obj 对象
   * @param {String} name 属性名
   * @param {Object} context 属性定义
   * @param {Boolean} compatible 是否使用兼容方式
   * @static
   */
  owner.defineProperty = function (obj, name, context, compatible) {
    if (!obj || !name || !context) return;
    var self = this;
    context.set = context.set || function () {
      throw 'do not implement ' + name + ' setter.';
    };
    context.get = context.get || function () {
      throw 'do not implement ' + name + ' getter.';
    };
    //--
    if (!compatible) {
      if (obj.__defineGetter__ && obj.__defineSetter__) {
        obj.__defineSetter__(name, context.set);
        obj.__defineGetter__(name, context.get);
      } else if (Object.defineProperty) {
        try {
          Object.defineProperty(obj, name, context);
        } catch (ex) { }
      }
    }
    //--
    if (!self.has(obj, name)) {
      obj[name] = function (value) {
        var method = self.isNull(value) ? 'get' : 'set';
        return context[method].apply(obj, arguments || []);
      };
    }
    return obj[name];
  };

  /**
   * 对象变换
   **/
  owner.map = function (list, fn) {
    var buffer = this.isArray(list) ? [] : {};
    this.each(list, function (name, value) {
      buffer[name] = fn(name, value);
    });
    return buffer;
  };

  /**
   * 通过路径设置属性值
   */
  owner.setByPath = function (obj, path, value) {
    if (this.isNull(obj) || this.isNull(path) || path === '') {
      return;
    }
    if (!this.isArray(path)) {
      path = path.replace(/\[/, '.').replace(/\]/, '.').split('.');
    }
    this.each(path, function (index, name) {
      if (this.isNull(name) || name.length < 1) return;
      if (index === path.length - 1) {
        obj[name] = value;
      } else {
        obj[name] = obj[name] || {};
        obj = obj[name];
      }
    }, this);
  };

  /**
   * 通过路径获取属性值
   */
  owner.getByPath = function (obj, path) {
    if (this.isNull(obj) || this.isNull(path) || path === '') {
      return obj;
    }
    if (!this.isArray(path)) {
      path = path.replace(/\[/, '.').replace(/\]/, '.').split('.');
    }
    this.each(path, function (index, name) {
      if (this.isNull(name) || name.length < 1) return;
      if (!this.isNull(obj)) obj = obj[name];
    }, this);
    return obj;
  };

  /**
   * 数组去重
   **/
  owner.unique = function (array) {
    if (this.isNull(array)) return array;
    var newArray = [];
    var map = {};
    this.each(array, function (i, value) {
      if (map[value]) return;
      map[value] = true;
      newArray.push(value);
    });
    return newArray;
  };

  /**
   * 解析 function 的参数列表
   **/
  owner.getFunctionArgumentNames = function (fn) {
    if (!fn) return [];
    var src = fn.toString();
    var parts = src.split(')')[0].split('=>')[0].split('(');
    return (parts[1] || parts[0]).split(',').map(function (name) {
      return name.trim();
    }).filter(function (name) {
      return name != 'function';
    });
  };

  /**
   * 处理URL
   * @method wrapUrl
   * @param  {String} _url 原始URL
   * @return {String}      处理过的URL
   * @static
   */
  owner.wrapUrl = function (url) {
    if (this.isNull(url)) return url;
    if (url.indexOf('?') > -1) {
      url += "&__t=" + this.newGuid();
    } else {
      url += "?__t=" + this.newGuid();
    }
    return url;
  };

  /**
   * 休眼
   * @method sleep
   * @param {Number} s 休眠时间（毫秒）
   * @static
   */
  owner.sleep = function (s) {
    var time = (new Date()).getTime() + s;
    while ((new Date()).getTime() + 1 < time);
    return;
  };

  /**
   * 合并对象
   * @method mix
   * @return 合并后的对象
   * @param {Object} r 目标对象
   * @param {Object} s 源对象
   * @param {Boolean} ov 是否覆盖
   * @param {Object} wl 白名单
   * @param {Number} mode 模式
   * @param {Boolean} merge 深度合���
   */
  owner.mix = function (r, s, ov, wl, mode, merge) {
    if (!s || !r) {
      return r || owner;
    }
    //根据模式来判断，默认是Obj to Obj的  
    if (mode) {
      switch (mode) {
        case 1: // proto to proto  
          return owner.mix(r.prototype, s.prototype, ov, wl, 0, merge);
        case 2: // object to object and proto to proto  
          owner.mix(r.prototype, s.prototype, ov, wl, 0, merge);
          break; // pass through  
        case 3: // proto to static  
          return owner.mix(r, s.prototype, ov, wl, 0, merge);
        case 4: // static to proto  
          return owner.mix(r.prototype, s, ov, wl, 0, merge);
        default: // object to object is what happens below  
      }
    }
    // Maybe don't even need this wl && wl.length check anymore??  
    var i, l, p, type;
    //白名单如果有值，就对白名单里面的属性进行合并，如果有ov，那么就  
    if (wl && wl.length) {
      for (i = 0, l = wl.length; i < l; ++i) {
        p = wl[i];
        isObject = owner.isObject(r[p]); //看具体的属性是什么类型的  
        if (s.hasOwnProperty(p)) { //如果这个属性是p自己的  
          if (merge && isObject) { //如果设定了merge并且属性是一个对象，那么就调用mix本身，把s[p]的属性加到r[p]上面  
            owner.mix(r[p], s[p]);
          } else if (ov || !(p in r)) { //如果允许ov或者r里面没有p，那么就在r里面加上p这个属性  
            r[p] = s[p];
          }
        }
      }
    } else { //如果没有wl  
      for (i in s) { //遍历s里面的属性  
        if (s.hasOwnProperty(i)) { //如果i是s本身的属性，就按规则合并属性  
          if (merge && owner.isObject(r[i], true)) {
            owner.mix(r[i], s[i], ov, wl, 0, true); // recursive  
          } else if (ov || !(i in r)) {
            r[i] = s[i];
          }
        }
      }
    }
    return r;
  };

  /**
   * 缩短字符串
   */
  owner.short = function (str, maxLength) {
    if (!str) return str;
    maxLength = maxLength || 40;
    var strLength = str.length;
    var trimLength = maxLength / 2;
    return strLength > maxLength ? str.substr(0, trimLength) + '...' + str.substr(strLength - trimLength) : str;
  };

  /**
   * 首字母大写
   */
  owner.firstUpper = function (str) {
    var self = this;
    if (self.isNull(str)) return;
    str = str.toLowerCase();
    var buffer = [];
    for (var i in str) {
      if (i == 0) {
        buffer.push(str[i].toUpperCase());
      } else {
        buffer.push(str[i]);
      }
    };
    return buffer.join('');
  };

  //----

  //兼容AMD模块
  if (typeof define === 'function' && define.amd) {
    define('ntils', [], function () {
      return owner;
    });
  }

})((typeof exports === 'undefined') ? (window.ntils = {}) : exports);
//-
},{}],16:[function(require,module,exports){
module.exports={
  "name": "mov",
  "version": "0.0.1",
  "description": "",
  "main": "./lib/index.js",
  "scripts": {
    "start": "nokit stop && nokit start --public ./ --port 8002",
    "build": "browserify ./lib/index.js | uglifyjs  > ./dist/bundle.js",
    "watch": "watchify ./lib/index.js -o 'exorcist ./dist/bundle.js.map > ./dist/bundle.js' -d"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "browserify": "^13.1.0",
    "exorcist": "^0.4.0",
    "nokitjs": "^1.25.9",
    "uglifyify": "^3.0.3",
    "watchify": "^3.7.0"
  },
  "dependencies": {
    "cify": "^1.0.2",
    "ntils": "^1.0.7"
  }
}

},{}]},{},[2])
//# sourceMappingURL=bundle.js.map
